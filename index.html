<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Swatch</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .game-container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            max-width: 400px;
            width: 100%;
        }

        .title {
            text-align: center;
            font-size: 32px;
            font-weight: bold;
            color: #333;
            margin-bottom: 30px;
        }

        .color-display {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
        }

        .color-box {
            flex: 1;
            height: 100px;
            border-radius: 15px;
            border: 3px solid #ddd;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .color-label {
            position: absolute;
            bottom: -25px;
            font-size: 14px;
            font-weight: 600;
            color: #666;
        }

        .hex-code {
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 12px;
            font-family: monospace;
        }

        .harmony-meter {
            margin-bottom: 30px;
            text-align: center;
        }

        .meter-label {
            font-size: 16px;
            color: #5a6b5d;
            margin-bottom: 10px;
            font-weight: 500;
        }

        .meter-bar {
            width: 100%;
            height: 12px;
            background: #e8f0e8;
            border-radius: 20px;
            overflow: hidden;
            margin-bottom: 8px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }

        .meter-fill {
            height: 100%;
            background: linear-gradient(90deg, #c8e6c9 0%, #81c784 50%, #4caf50 100%);
            width: 0%;
            transition: width 0.5s ease, background 0.3s ease;
            border-radius: 20px;
        }

        .meter-text {
            font-size: 14px;
            color: #6a7b6d;
            font-style: italic;
        }

        .stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            font-weight: 600;
            color: #333;
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .color-swatch {
            aspect-ratio: 1;
            border-radius: 10px;
            border: 2px solid #ddd;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
            position: relative;
        }

        .color-swatch:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .color-swatch:active {
            transform: scale(0.95);
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        .btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-undo {
            background: #ffab91;
            color: white;
        }

        .btn-undo:disabled {
            background: #e0e0e0;
            cursor: not-allowed;
        }

        .btn-reset {
            background: #9c27b0;
            color: white;
        }

        .btn-new {
            background: #81c784;
            color: white;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .success {
            text-align: center;
            margin-top: 20px;
            padding: 15px;
            background: #e8f5e8;
            border-radius: 10px;
            color: #2e5c2e;
            font-weight: 600;
        }

        .accuracy {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="title">🌺 Color Harmony</div>
        
        <div class="color-display">
            <div class="color-box" id="targetColor">
                <div class="hex-code" id="targetHex">#000000</div>
                <div class="color-label">Target</div>
            </div>
            <div class="color-box" id="currentColor">
                <div class="hex-code" id="currentHex">#808080</div>
                <div class="color-label">Your Mix</div>
            </div>
        </div>

        <div class="harmony-meter">
            <div class="meter-label">Harmony</div>
            <div class="meter-bar">
                <div class="meter-fill" id="harmonyFill"></div>
            </div>
            <div class="meter-text" id="harmonyText">Find your first color...</div>
        </div>

        <div class="stats">
            <span>Steps: <span id="moveCount">0</span></span>
            <span>Best: <span id="bestScore">-</span></span>
        </div>

        <div class="color-grid" id="colorGrid"></div>

        <div class="controls">
            <button class="btn btn-reset" id="resetBtn">Reset Harmony</button>
            <button class="btn btn-new" id="newGameBtn">New Harmony</button>
        </div>

        <div id="successMessage" class="success" style="display: none;"></div>
    </div>

    <script>
        class ColorSwatchGame {
            constructor() {
                this.targetColor = '#000000';
                this.currentColor = '#ffffff';
                this.moves = 0;
                this.colorHistory = ['#ffffff'];
                this.bestScore = localStorage.getItem('colorSwatchBest') || null;
                this.gameWon = false;
                this.firstColorPicked = false;
                this.solutionPath = []; // The colors used to create the target
                this.solutionSteps = 0;
                
                this.initElements();
                this.newGame();
                this.updateDisplay();
            }

            initElements() {
                this.targetColorEl = document.getElementById('targetColor');
                this.currentColorEl = document.getElementById('currentColor');
                this.targetHexEl = document.getElementById('targetHex');
                this.currentHexEl = document.getElementById('currentHex');
                this.moveCountEl = document.getElementById('moveCount');
                this.bestScoreEl = document.getElementById('bestScore');
                this.colorGridEl = document.getElementById('colorGrid');
                this.resetBtnEl = document.getElementById('resetBtn');
                this.newGameBtnEl = document.getElementById('newGameBtn');
                this.successEl = document.getElementById('successMessage');
                this.harmonyFillEl = document.getElementById('harmonyFill');
                this.harmonyTextEl = document.getElementById('harmonyText');

                this.resetBtnEl.addEventListener('click', () => this.resetPuzzle());
                this.newGameBtnEl.addEventListener('click', () => this.newGame());
            }

            generateRandomColor() {
                return '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
            }

            // NEW: Generate a guaranteed solvable puzzle
            generateSolvablePuzzle() {
                // Start with white base
                let currentColor = '#ffffff';
                const solutionColors = [];
                const baseColors = [
                    '#ff0000', // Red
                    '#0000ff', // Blue  
                    '#ffff00', // Yellow
                    '#00ff00', // Green
                    '#ff8000', // Orange
                    '#8000ff', // Purple
                    '#ff0080', // Pink
                    '#000000'  // Black
                ];
                
                // Generate 3-5 steps to create target
                const numSteps = 3 + Math.floor(Math.random() * 3); // 3-5 steps
                
                for (let i = 0; i < numSteps; i++) {
                    const mixColor = baseColors[Math.floor(Math.random() * baseColors.length)];
                    currentColor = this.blendColors(currentColor, mixColor, 0.5);
                    solutionColors.push(mixColor);
                }
                
                return {
                    targetColor: currentColor,
                    solutionPath: solutionColors,
                    steps: numSteps
                };
            }

            // NEW: Generate strategic palette with solution + distractors
            generateStrategicPalette(solutionPath) {
                const palette = [...solutionPath]; // Include all solution colors
                
                // Add strategic distractors
                const distractors = [
                    '#ff0000', '#0000ff', '#ffff00', '#00ff00', 
                    '#ff8000', '#8000ff', '#ff0080', '#000000',
                    '#ffffff', '#808080', '#400040', '#004040'
                ];
                
                // Fill remaining slots with distractors (avoid duplicates)
                while (palette.length < 12) {
                    const distractor = distractors[Math.floor(Math.random() * distractors.length)];
                    if (!palette.includes(distractor)) {
                        palette.push(distractor);
                    }
                }
                
                // Shuffle so solution isn't obvious
                return this.shuffleArray(palette.slice(0, 12));
            }

            shuffleArray(array) {
                const shuffled = [...array];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            }

            generateColorPalette() {
                // OLD METHOD - no longer used
                const colors = [];
                for (let i = 0; i < 12; i++) {
                    colors.push(this.generateRandomColor());
                }
                return colors;
            }

            hexToRgb(hex) {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return { r, g, b };
            }

            rgbToHex(r, g, b) {
                return '#' + [r, g, b].map(x => {
                    const hex = Math.round(x).toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                }).join('');
            }

            blendColors(color1, color2, ratio = 0.5) {
                const rgb1 = this.hexToRgb(color1);
                const rgb2 = this.hexToRgb(color2);
                
                const r = rgb1.r * (1 - ratio) + rgb2.r * ratio;
                const g = rgb1.g * (1 - ratio) + rgb2.g * ratio;
                const b = rgb1.b * (1 - ratio) + rgb2.b * ratio;
                
                return this.rgbToHex(r, g, b);
            }

            getColorDistance(color1, color2) {
                const rgb1 = this.hexToRgb(color1);
                const rgb2 = this.hexToRgb(color2);
                
                const dr = rgb1.r - rgb2.r;
                const dg = rgb1.g - rgb2.g;
                const db = rgb1.b - rgb2.b;
                
                return Math.sqrt(dr*dr + dg*dg + db*db);
            }

            calculateHarmony() {
                if (!this.firstColorPicked) return 0;
                
                const distance = this.getColorDistance(this.currentColor, this.targetColor);
                const maxDistance = 441.67; // Max possible distance in RGB space
                const harmony = Math.max(0, 100 - (distance / maxDistance * 100));
                return Math.round(harmony);
            }

            selectColor(color) {
                if (this.gameWon) return;
                
                this.moves++;
                
                if (!this.firstColorPicked) {
                    // First color becomes your base - no blending
                    this.currentColor = color;
                    this.firstColorPicked = true;
                } else {
                    // Blend with current color
                    this.currentColor = this.blendColors(this.currentColor, color, 0.5);
                }
                
                this.colorHistory.push(this.currentColor);
                
                this.updateDisplay();
                this.checkWin();
            }

            checkWin() {
                const distance = this.getColorDistance(this.currentColor, this.targetColor);
                const accuracy = Math.max(0, 100 - (distance / 441.67 * 100)); // 441.67 is max distance in RGB space
                
                if (distance < 22) { // 95% accuracy required - much tighter!
                    this.gameWon = true;
                    this.showSuccess(accuracy);
                    
                    if (!this.bestScore || this.moves < this.bestScore) {
                        this.bestScore = this.moves;
                        localStorage.setItem('colorSwatchBest', this.bestScore);
                        this.bestScoreEl.textContent = this.bestScore;
                    }
                }
            }

            resetPuzzle() {
                // Reset to starting state but keep same target and palette
                this.currentColor = '#ffffff';
                this.moves = 0;
                this.colorHistory = ['#ffffff'];
                this.gameWon = false;
                this.firstColorPicked = false;
                this.successEl.style.display = 'none';
                
                this.updateDisplay();
            }

            showSuccess(accuracy) {
                let message = "🌸 Perfect harmony achieved";
                if (this.moves <= 3) message = "✨ Masterful balance in " + this.moves + " steps";
                else if (this.moves <= 5) message = "🍃 Graceful harmony in " + this.moves + " steps";
                else message = "🌱 Peaceful completion in " + this.moves + " steps";
                
                // Show optimal solution
                const solutionColors = this.solutionPath.map(color => {
                    if (color === '#ff0000') return 'Red';
                    if (color === '#0000ff') return 'Blue';
                    if (color === '#ffff00') return 'Yellow';
                    if (color === '#00ff00') return 'Green';
                    if (color === '#ff8000') return 'Orange';
                    if (color === '#8000ff') return 'Purple';
                    if (color === '#ff0080') return 'Pink';
                    if (color === '#000000') return 'Black';
                    return color;
                }).join(' → ');
                
                let solutionText = '';
                if (this.moves === this.solutionSteps) {
                    solutionText = `<div style="margin-top: 8px; font-size: 12px; color: #4caf50;">⚡ Optimal solution! ${solutionColors}</div>`;
                } else {
                    solutionText = `<div style="margin-top: 8px; font-size: 12px; color: #666;">Fastest route (${this.solutionSteps} steps): ${solutionColors}</div>`;
                }
                
                this.successEl.innerHTML = `
                    ${message}
                    <div class="accuracy">${accuracy.toFixed(1)}% harmony</div>
                    ${solutionText}
                `;
                this.successEl.style.display = 'block';
            }

            undo() {
                if (this.undosLeft <= 0 || this.colorHistory.length <= 1 || this.gameWon) return;
                
                this.undosLeft--;
                this.colorHistory.pop();
                this.currentColor = this.colorHistory[this.colorHistory.length - 1];
                this.moves = Math.max(0, this.moves - 1);
                
                // If we're back to the starting white, reset firstColorPicked
                if (this.colorHistory.length === 1) {
                    this.firstColorPicked = false;
                }
                
                this.updateDisplay();
            }

            newGame() {
                // Generate guaranteed solvable puzzle
                const puzzle = this.generateSolvablePuzzle();
                this.targetColor = puzzle.targetColor;
                this.solutionPath = puzzle.solutionPath;
                this.solutionSteps = puzzle.steps;
                
                this.currentColor = '#ffffff';
                this.moves = 0;
                this.colorHistory = ['#ffffff'];
                this.gameWon = false;
                this.firstColorPicked = false;
                this.successEl.style.display = 'none';
                
                this.generateNewPalette();
                this.updateDisplay();
            }

            generateNewPalette() {
                const colors = this.generateStrategicPalette(this.solutionPath);
                this.colorGridEl.innerHTML = '';
                
                colors.forEach(color => {
                    const swatch = document.createElement('div');
                    swatch.className = 'color-swatch';
                    swatch.style.backgroundColor = color;
                    swatch.addEventListener('click', () => this.selectColor(color));
                    this.colorGridEl.appendChild(swatch);
                });
            }

            updateDisplay() {
                this.targetColorEl.style.backgroundColor = this.targetColor;
                this.currentColorEl.style.backgroundColor = this.currentColor;
                this.targetHexEl.textContent = this.targetColor.toUpperCase();
                
                const harmony = this.calculateHarmony();
                
                if (!this.firstColorPicked) {
                    this.currentHexEl.textContent = 'PICK ONE!';
                    this.currentColorEl.style.border = '3px dashed #ccc';
                    this.harmonyFillEl.style.width = '0%';
                    this.harmonyTextEl.textContent = 'Find your first color...';
                } else {
                    this.currentHexEl.textContent = this.currentColor.toUpperCase();
                    this.currentColorEl.style.border = '3px solid #ddd';
                    this.harmonyFillEl.style.width = harmony + '%';
                    
                    if (harmony >= 95) this.harmonyTextEl.textContent = `${harmony}% ✨ Perfect harmony!`;
                    else if (harmony >= 90) this.harmonyTextEl.textContent = `${harmony}% 🌸 Nearly there...`;
                    else if (harmony >= 80) this.harmonyTextEl.textContent = `${harmony}% 🍃 Getting warmer...`;
                    else if (harmony >= 60) this.harmonyTextEl.textContent = `${harmony}% 🌱 Keep exploring...`;
                    else this.harmonyTextEl.textContent = `${harmony}% harmony`;
                }
                
                this.moveCountEl.textContent = this.moves;
                this.bestScoreEl.textContent = this.bestScore || '-';
            }
        }

        // Start the game
        new ColorSwatchGame();
    </script>
</body>
</html>
